**Explanation for how volumes are processed when added to a sub-level**

- When a sub-level loads, it loops all its actors and instantiate/initialize them and their components (`AActor::IncrementalRegisterComponents(int32 NumComponentsToRegister, FRegisterComponentContext* Context)`).
- In the case of the Nav Mesh Volumes, when they are added to the level, during their PostRegisterComponents, there's a callback to the Navigation System informing about a new Nav Volume Added

```jsx
void ANavMeshBoundsVolume::PostRegisterAllComponents() 
{
	Super::PostRegisterAllComponents();
	
	UNavigationSystemV1* NavSys = FNavigationSystem::GetCurrent<UNavigationSystemV1>(GetWorld());
	if (NavSys && GetLocalRole() == ROLE_Authority)
	{
		NavSys->OnNavigationBoundsAdded(this);
	}
}
```

- It's then when the Nav System runs `UNavigationSystemV1::AddNavigationBoundsUpdateRequest` to add them to the `PendingNavBoundsUpdates`. Later, during `UNavigationSystemV1::ConditionalPopulateNavOctree()` the bounds will be processed and the Octree updated `NavHandler.ProcessPendingOctreeUpdates();`

**Explanation on where is the nav data added to each sub-level**

- The nav information that Level should have is stored in an object called `URecastNavMeshDataChunk` . Each level has a `TArray<UNavigationDataChunk*>` . Even though a Level can have several chunks in said array, I only have seen one per sub-level so far. Moreover, the function that returns the NavDataChunk of a Level (`URecastNavMeshDataChunk* ARecastNavMesh::GetNavigationDataChunk(ULevel* InLevel)` ) only seems to return the first occurrence where the name matches.
- `URecastNavMeshDataChunk` has the a  `TArray<FRecastTileData>` with all the Tiles belonging to said chunk. In other words: this object knows which tiles belong to this level. You can attach/detach/move and get tiles through this object. One thing to keep in mind: all the tiles, the entire tile set of the world, lives in the `URecastNavMesh` object. The tiles in the Tiles array within a Level's nav data chunk are a copy from the "original" set of tiles in the Recast Object
- When you build paths (build nav) for your level, once it has finished, `void ARecastNavMesh::OnNavMeshGenerationFinished()` will be called. It's at this point where the engine will generate nav data chunks for your sub-levels if (and only if) they support Streaming. In other words: if you don't have a game where levels are streamed in, there will be no nav data chunks and nav will not be streamed in, but loaded entirely on the persistent level. The engine will loop the sub-levels and, if no nav data chunk is found, a new one will be created. Then, from the registered nav volumes in your level, the ones belonging to the currently processed level will be collected. Once it has the nav mesh volumes own by the level, the engine gets the tiles generated by them volumes. The tiles information will then be copied into the Level Nav Data Chunk. From this moment on, you will always know which tiles belong to each sub-level.

**Explanation on where is the nav data added to the game when streaming in a sub-level**

- When a sub-level is streamed into the world, this is the "callstack": `ULevelStreaming::UpdateStreamingState(bool& bOutUpdateAgain, bool& bOutRedetermineTarget)` → `UWorld::AddToWorld( ULevel* Level, const FTransform& LevelTransform, bool bConsiderTimeLimit )` → `UNavigationSystemV1::OnLevelAddedToWorld(ULevel* InLevel, UWorld* InWorld)` → `ARecastNavMesh::OnStreamingLevelAdded(ULevel* InLevel, UWorld* InWorld)`
- It's in `ARecastNavMesh::OnStreamingLevelAdded(ULevel* InLevel, UWorld* InWorld)` where the engine will then grab the nav data chunk of the streamed in level and attach its tiles calling `ARecastNavMesh::AttachNavMeshDataChunk(URecastNavMeshDataChunk& NavDataChunk)`
- Attach here means "add the tiles to the `dtNavMesh` object instance". Long story short: UE4 uses a library called Detour Recast NavMesh. All the low level information (tiles, polygons in each tile, generation settings etc) are really stored in objects "outside" unreal's code. The navigation available at any point in your game is extracted and processed in/out the `DetourNavMesh` owned by the `FPImplRecastNavMesh` object. In our case, this is the RecastNavMesh object generated when you build paths.

**Explanation on where is the nav data removed from the game when streaming out a sub-level**

- When a sub-level is streamed out from the world, this is the "callstack": `ULevelStreaming::UpdateStreamingState(bool& bOutUpdateAgain, bool& bOutRedetermineTarget)` → `UWorld::RemoveFromWorld( ULevel* Level, bool bAllowIncrementalRemoval )` → `UNavigationSystemV1::OnLevelRemovedFromWorld(ULevel* InLevel, UWorld* InWorld)` → `ARecastNavMesh::OnStreamingLevelRemoved(ULevel* InLevel, UWorld* InWorld)`
- It's in `ARecastNavMesh::OnStreamingLevelRemoved(ULevel* InLevel, UWorld* InWorld)` where the engine will look for the Nav Data Chunk of that level and detach it from the `DetourNavMesh` object (`dtNavMesh` ) within `URecastNavMeshDataChunk::DetachTiles(FPImplRecastNavMesh& NavMeshImpl, const bool bTakeDataOwnership, const bool bTakeCacheDataOwnership)` .
- The engine will loop through all the tiles info found in the Nav Data Chunk of the level and remove them from the `RecastObject::DetourNavMesh`