**The problem**

![Bug](BugImages/bug.gif)

[UDN Post to the problem](https://udn.unrealengine.com/s/question/0D54z00007Ajn8xCAB/streaming-out-sublevels-with-overlapping-nav-volumes-will-remove-each-others-nav)


Streaming out Sub-levels with overlapping nav volumes will remove each others nav.

Our nav configuration is Dynamic with Modifiers and we don't have Nav volumes in the persistent level (except for a small mandatory one).

- we have the persistent level with 3 stream volumes that overlap.
  - **LevelStreamingVolume_Left** streams in **LVL_Left**. This brings in a floor and a nav volume
  ![Bug](BugImages/Left_LVL.jpg)
  - **LevelStreamingVolume_Right** streams in **LVL_Right**. This brings in a floor and a nav volume
  ![Bug](BugImages/Right_LVL.jpg)
  - **LevelStreamingVolume_Centre** streams in **LVL_Centre**. This brings in a floor and a nav volume
  ![Bug](BugImages/Centre_LVL.jpg)
   
- Because how big the nav volumes are, the nav is generated like this
![Bug](BugImages/navGenerated.png)

- When the game starts, the player is overlapping the three stream volumes, so all the levels with their Nav Volumes stream in. It looks like this

![Bug](BugImages/start.jpg)

- If I start overlapping just the right or the left volumes, we can see the corresponding levels and the nav they generate. Images are from streaming only the left level and only the right level

![Bug](BugImages/start_left.jpg)
![Bug](BugImages/start_right.jpg)

- But, when moving from left to right (or vice versa), we can see how this happens:
  - Move all the way to the left. Only LVL_Left is there (left floor and nav)
  - Move towards the right. At some point the player overlaps the three volumes. So all levels and all the nav can be seen.
  - Keep moving to the right. Now the player overlaps stream volumes for Centre and Right. Then LVL_Left un-streams (streams out?)
  - Observe how, when removing the Left Nav Volume, it takes with it the nav the Right Nav Volume generated in the overlapping area.

- If the level is streamed out and back in, the nav is back to normal (better observed in the gif rather than images themselves).

As stated in the documentation found here [UDN Post to the problem](https://udn.unrealengine.com/s/question/0D54z00007Ajn8xCAB/streaming-out-sublevels-with-overlapping-nav-volumes-will-remove-each-others-nav) (if you don't know what a Nav Data Chunk is or how it works, please read that link before continuing), 
the process is clear: we have nav data for each level. When the level is available, the engine adds its tile info to the world (from its NavDataChunk) and, when the level is removed, it will remove its tiles from the world. And here comes the problem:

**two overlapping NavMeshVolumes will generate tiles on a shared location, but the tile/s generated will be the same. In other words: each volume will not generate a new tile, but share the same tile generated by the first volume processed.**

What this means in the case of streaming is this:

- You have VolumeA within SubLevelA
- You have VolumeB within SubLevelB
- Both, VolumeA and VolumeB, overlap
- When Build Paths is called, it generates tiles based on the volumes placed. Overlapping volumes will share one or more tiles.
- The NavChunkData for each level will be generated. One will contain tiles for SubLevelA and the other for SubLevelB based on the Nav Mesh volumes they own.
- The shared tile is "shared" because it will be copied over to both nav data chunks for both levels since it was generated by the both volumes in both levels. In reality, it's the same tile copied to two different data objects. What I mean: yhe engine vill not generate 2 tiles in the same place because 2 volumes overlap. It will just generate one.
- When both levels are available (streamed in), not a problem. All the Nav Data Chunks will be loaded, which means all the tiles will be there
- The problem: let's say we stream out SubLevelA. As explained before, its nav chunk will be processed and all the tiles within it will be remove. **It's at this point where the shared tile (copy of the same tile in both nav data chunks) will be removed.** The engine never checks if a tile belongs to a NavDataChunk that is loaded, in other words: it doesn't check if the tile to be removed is needed by a still loaded sub-level

**The Solution: check if a tile belongs also to another sub-level before detaching it from the world**

**Disclaimer #1:** I did first an attempt to check if a tile existed in any other data chunk by checking the Tile ID. I failed to find a good way. I don't have notes on why but it seems that there was some missmatch with TileID's, even though they are copies from the original set. I ended up doing my Plan B, described above. This doesn't mean the TileID approach doesn't work, it's just I hit a wall and didn't have time to keep digging. If you find a way to do it, please feel free to share it. It will be probably the optimal way to do it.

**Disclaimer #2:** I let the tiles to be removed and then I re-added the nav data chunks owning the tiles we need to not be removed (the shared tiles between sub-levels) to the nav data. I tried briefly to just skip the deletion of said tiles, but I had all shorts of errors. Due time constrains, I decided to prototype with the idea "ok, delete and I will re-add". But it became the solution itself and never came back to it. I'm sure there's an optimal way that will skip the deletion part. If you find a way for it, let me know. 

**Disclaimer #3:** At some point we will do a `FBoxSphereBounds::BoxesIntersect` using the bounds of a tile against the bounds of a Nav Mes Volume. There's a problem where, sometimes, the bounds of a tile will not be valid. At the moment of writing this, I have no idea why it happens (never looked into it). As a temporary fix, I force the Tile to be re-added to the nav data.

**Step 1: hold control of the nav volumes of each level**

While the engine already provides a way to find all the NavBoundsVolumes belonging to a level (`TArray<FBox> ANavigationData::GetNavigableBoundsInLevel(ULevel* InLevel) const`) I preferred to do my own subsystem rather than use that function. The reason is that, the provided function, loops through all the RegisteredNavBounds nav volumes, which are all the loaded nav volumes in the game. While looping, it checks if the volumes belongs to the level we're passing to the function. I prefer to have them organized already and skip this looping. A level can have many volumes.

The way I did it:

- Add a subsystem to register/unregister nav volumes

**.h**

```cpp
#pragma once

#include "Subsystems/GameInstanceSubsystem.h"
#include "NavMesh/NavMeshBoundsVolume.h"
#include "MyNavBoundsVolumeManagerSubsystem.generated.h"

/** Wrapper for the registered nav volumes data*/
USTRUCT()
struct FLevelNavBoundsContainer
{
	GENERATED_BODY()

	FLevelNavBoundsContainer() :
		OwningLevel(nullptr)
	{
		OwnedNavVolumes.Reserve(20);
	}

	// Helper constructor for easy use of Emplace
	FLevelNavBoundsContainer(ANavMeshBoundsVolume* boundInLevel)
	{
		OwningLevel = Cast<ULevel>(boundInLevel->GetLevel());
		if (::IsValid(OwningLevel))
		{
			OwnedNavVolumes.Reserve(20);
			if (::IsValid(boundInLevel))
			{
				OwnedNavVolumes.Add(boundInLevel);
			}
		}
	}

	bool IsValid() const
	{
		return ::IsValid(OwningLevel);
	}

	bool operator==(const FLevelNavBoundsContainer& other)
	{
		return OwningLevel == other.OwningLevel;
	}

	// The level that owns the nav volumes
	UPROPERTY(Transient)
	ULevel* OwningLevel = nullptr;

	// All the available nav volumes for the OwningLevel
	UPROPERTY(Transient)
	TArray<ANavMeshBoundsVolume*> OwnedNavVolumes;
};

/** Subsystem to easily get access to all nav bounds volumes available in the world*/
UCLASS()
class UMyNavBoundsVolumeManagerSubsystem : public UGameInstanceSubsystem
{
	GENERATED_BODY()

public:
	virtual void Initialize(FSubsystemCollectionBase& Collection) override;
	virtual void Deinitialize() override;
	/** Add a new added volume to the level to the local collection*/
	void RegisterNavBoundsVolume(ANavMeshBoundsVolume* navBoundsToRegister);
	/** Remove a volume from the collection once it has been removed from its level*/
	void UnRegisterNavBoundsVolume(ANavMeshBoundsVolume* navBoundsToRegister);
	/** Get all nav volumes own by a level*/
	void GetVolumesFromLevel(ULevel* levelToSearch, TArray<ANavMeshBoundsVolume*>& outNavVolumesFromLevel) const;

private:
	/** Returns the container info wrapper of the passed volume (if any)*/
	FLevelNavBoundsContainer* FindContainerByNavVolume(ANavMeshBoundsVolume* navBoundsToQuery);
	/** const version of FindContainerByNavVolume*/
	const FLevelNavBoundsContainer* FindContainerByNavVolume(ANavMeshBoundsVolume* navBoundsToQuery) const;
	/** Returns the container info wrapper of the passed level (if any)*/
	FLevelNavBoundsContainer* FindContainerByLevel(ULevel* levelToQuery);
	/** const version of FindContainerByLevel*/
	const FLevelNavBoundsContainer* FindContainerByLevel(ULevel* levelToQuery) const;

	/** Outputs the container ref rather than return it as a pointer to ease removal of containers from collections
	 * @out outContainer: the container found or a default invalid one
	 * @return: true if a container was found*/
	bool FindRefContainerByLevel(ULevel* levelToQuery, FLevelNavBoundsContainer& outContainer);

	// We need this function because nav volumes are not removed from the world when the world is removed
	void OnLevelRemovedFromWorld(ULevel* InLevel, UWorld* InWorld);

private:
	// The registered levels-navVolumes available in the game
	UPROPERTY(Transient)
	TArray<FLevelNavBoundsContainer> AvailableNavBounds;

	// const initializer for the collection
	const int32 InitalArraySize = 50;
};
```

**.cpp**

```cpp
#include "MyNavBoundsVolumeManagerSubsystem.h"
#include "Algo/Transform.h"

void UMyNavBoundsVolumeManagerSubsystem::Initialize(FSubsystemCollectionBase& collection)
{
	Super::Initialize(collection);
	AvailableNavBounds.Reserve(InitalArraySize);

	// The engine does not remove the nav volumes when removing a level from the world, so we need to listen to this to
	// clean the array
	FWorldDelegates::LevelRemovedFromWorld.AddUObject(this,
		&UMyNavBoundsVolumeManagerSubsystem::OnLevelRemovedFromWorld);
}

void UMyNavBoundsVolumeManagerSubsystem::Deinitialize()
{
	FWorldDelegates::LevelRemovedFromWorld.RemoveAll(this);
	Super::Deinitialize();
}

void UMyNavBoundsVolumeManagerSubsystem::RegisterNavBoundsVolume(ANavMeshBoundsVolume* navBoundsToRegister)
{
	FLevelNavBoundsContainer* foundContainer = FindContainerByNavVolume(navBoundsToRegister);
	
	if (foundContainer != nullptr)
	{
		foundContainer->OwnedNavVolumes.AddUnique(navBoundsToRegister);
	}
	else
	{
		foundContainer = &AvailableNavBounds[AvailableNavBounds.Emplace(navBoundsToRegister)];
	}
}

void UMyNavBoundsVolumeManagerSubsystem::UnRegisterNavBoundsVolume(ANavMeshBoundsVolume* navBoundsToRegister)
{
	FLevelNavBoundsContainer* foundContainer = FindContainerByNavVolume(navBoundsToRegister);
	if (foundContainer != nullptr)
	{
		foundContainer->OwnedNavVolumes.RemoveSwap(navBoundsToRegister);
	}
}

void UMyNavBoundsVolumeManagerSubsystem::GetVolumesFromLevel(ULevel* levelToSearch,
	TArray<ANavMeshBoundsVolume*>& outNavVolumesFromLevel) const
{
	if (const FLevelNavBoundsContainer* foundContainer = FindContainerByLevel(levelToSearch))
	{
		auto transformLambda = [](ANavMeshBoundsVolume* navBound)
		{
			return navBound;
		};
		Algo::Transform(foundContainer->OwnedNavVolumes, outNavVolumesFromLevel, transformLambda);
	}
}

const FLevelNavBoundsContainer* UMyNavBoundsVolumeManagerSubsystem::FindContainerByNavVolume(ANavMeshBoundsVolume* navBoundsToQuery) const
{
	ULevel* owningLevel = ::IsValid(navBoundsToQuery) ? navBoundsToQuery->GetLevel() : nullptr;
	return FindContainerByLevel(owningLevel);
}

FLevelNavBoundsContainer* UMyNavBoundsVolumeManagerSubsystem::FindContainerByNavVolume(ANavMeshBoundsVolume* navBoundsToQuery)
{
	ULevel* owningLevel = ::IsValid(navBoundsToQuery) ? navBoundsToQuery->GetLevel() : nullptr;
	return FindContainerByLevel(owningLevel);
}

FLevelNavBoundsContainer* UMyNavBoundsVolumeManagerSubsystem::FindContainerByLevel(ULevel* levelToQuery)
{
	FLevelNavBoundsContainer* foundContainer = nullptr;
	if (::IsValid(levelToQuery))
	{
		auto searchLambda = [&levelToQuery](const FLevelNavBoundsContainer& container)
		{
			return container.IsValid() && (container.OwningLevel == levelToQuery);
		};
		foundContainer = AvailableNavBounds.FindByPredicate(searchLambda);
	}

	return foundContainer;
}

const FLevelNavBoundsContainer* UMyNavBoundsVolumeManagerSubsystem::FindContainerByLevel(ULevel* levelToQuery) const
{
	if (::IsValid(levelToQuery))
	{
		auto searchLambda = [&levelToQuery](const FLevelNavBoundsContainer& container)
		{
			return container.IsValid() && (container.OwningLevel == levelToQuery);
		};
		const FLevelNavBoundsContainer* foundContainer = AvailableNavBounds.FindByPredicate(searchLambda);
		return foundContainer;
	}
	return nullptr;
}

bool UMyNavBoundsVolumeManagerSubsystem::FindRefContainerByLevel(ULevel* levelToQuery, FLevelNavBoundsContainer& outContainer)
{
	FLevelNavBoundsContainer* foundContainer = nullptr;
	if (::IsValid(levelToQuery))
	{
		auto searchLambda = [&levelToQuery](const FLevelNavBoundsContainer& container)
		{
			return container.IsValid() && (container.OwningLevel == levelToQuery);
		};
		foundContainer = AvailableNavBounds.FindByPredicate(searchLambda);
	}

	outContainer = foundContainer != nullptr ? *foundContainer : FLevelNavBoundsContainer();
	return outContainer.IsValid();
}

void UMyNavBoundsVolumeManagerSubsystem::OnLevelRemovedFromWorld(ULevel* InLevel, UWorld* InWorld)
{
	// take the chance to clear any invalid elements belonging to a level that might have been GC'ed
	auto removeLambda = [](const FLevelNavBoundsContainer& navContainer)
	{
		return !navContainer.IsValid();
	};
	AvailableNavBounds.RemoveAll(removeLambda);

	// a NULL object means the LoadMap case, because all levels will be 
	// removed from the world without a RemoveFromWorld call for each
	if (InLevel != nullptr)
	{		
		FLevelNavBoundsContainer foundContainer;
		if (FindRefContainerByLevel(InLevel, foundContainer))
		{
			AvailableNavBounds.RemoveSwap(foundContainer);
		}
	}
}
```

- Create your own child for the Navigation System so we can react to when the nav volumes are added/removed to the world

**.h**

```cpp
#pragma once

#include "NavigationSystem/Public/NavigationSystem.h"
#include "MyNavigationSystem.generated.h"

class ANavMeshBoundsVolume;
class UMyNavBoundsVolumeManagerSubsystem;

DECLARE_LOG_CATEGORY_EXTERN(LogMyNavigationSystem, Log, All);

UCLASS(config = Engine, defaultconfig)
class MY_API UMyNavigationSystem : public UNavigationSystemV1
{
	GENERATED_BODY()

public:
	void OnNavigationBoundsAdded(ANavMeshBoundsVolume* navVolume) override;
	void OnNavigationBoundsRemoved(ANavMeshBoundsVolume* navVolume) override;

private:
	/** Try to set the local member NavSubsystem*/
	UMyNavBoundsVolumeManagerSubsystem* TryCacheNavBoundsSubsystem();
	/** Custom function to check if we are running the game (not working in editor or cooking)*/
	const bool IsRunningGame() const;

private:
	// NavSubsystem is where the nav volumes are registered
	UPROPERTY(Transient)
	UMyNavBoundsVolumeManagerSubsystem* NavSubsystem;
};
```

**.cpp**

```cpp
#include "MyNavigationSystem.h"

#include "NavMesh/NavMeshBoundsVolume.h"

#include "Game/MyGameInstance.h"
#include "MyNavBoundsVolumeManagerSubsystem.h"

DEFINE_LOG_CATEGORY(LogMyNavigationSystem);

void UMyNavigationSystem::OnNavigationBoundsAdded(ANavMeshBoundsVolume* navVolume)
{
	Super::OnNavigationBoundsAdded(navVolume);
	TryCacheNavBoundsSubsystem();
	if (::IsValid(NavSubsystem))
	{
		NavSubsystem->RegisterNavBoundsVolume(navVolume);
	}
	else if (IsRunningGame())
	{
		UE_LOG(LogMyNavigationSystem, Error, TEXT("%s NavVolume %s in level %s is not being registered because no subsystem was found!"),
			*FString(__FUNCTION__), *GetNameSafe(navVolume), *GetNameSafe(navVolume->GetLevel()));
	}
}

void UMyNavigationSystem::OnNavigationBoundsRemoved(ANavMeshBoundsVolume* navVolume)
{
	Super::OnNavigationBoundsRemoved(navVolume);
	TryCacheNavBoundsSubsystem();
	if (::IsValid(NavSubsystem))
	{
		NavSubsystem->UnRegisterNavBoundsVolume(navVolume);
	}
	else if (IsRunningGame())
	{
		UE_LOG(LogMyNavigationSystem, Error, TEXT("%s NavVolume %s in level %s is not being un-registered because no subsystem was found!"),
			*FString(__FUNCTION__), *GetNameSafe(navVolume), *GetNameSafe(navVolume->GetLevel()));
	}
}

UMyNavBoundsVolumeManagerSubsystem* UMyNavigationSystem::TryCacheNavBoundsSubsystem()
{
	if (!::IsValid(NavSubsystem))
	{
		const UWorld* world = GetWorld();
		const UMyGameInstance* myGameInstance = ::IsValid(world) ? world->GetGameInstance<UMyGameInstance>() : nullptr;
		NavSubsystem = ::IsValid(myGameInstance) ? myGameInstance->GetSubsystem<UMyNavBoundsVolumeManagerSubsystem>() : nullptr;
	}

	return NavSubsystem;
}

const bool UMyNavigationSystem::IsRunningGame() const
{
	const UWorld* world = GetWorld();
	const bool inGame = ::IsValid(world) ? ::IsValid(world->GetGameInstance<UMyGameInstance>()) : false;
	return inGame && !GIsCookerLoadingPackage;
}
```

- Now you need to tell the engine that you want to use your own NavSystem class. This is done in two steps:
    - Edit `[YourProjectName]\Config\DefaultEngine.ini` . Look for the entry `[/Script/Engine.Engine]` and modify this line
    
    ```cpp
    NavigationSystemClassName=/Script/YourProjectName.MyNavigationSystem
    ```
    
    - Once you re-boot your editor, you will need to edit the world settings in every level where you want to use your nav settings by selecting your NavSystem child. Unfortunately I never had the time to find an automated way to fix this.
    
    ![Untitled](BugImages/Untitled.png)
    
    From this moment on, every time a nav volume is added to the world, it will be registered into your nav volumes subsystem. Now you can easily get all the nav volumes belonging to any level in a quick way (examples of usage shown later)
    

- You also need to create your own version of `URecastNavMeshDataChunk`. This is to control what happens during the detaching tiles process in order to fix the bug. Within this class we will check if a tile overlaps a nav volume that belongs to a different sub-level. If that's the case, we will let the tile to be removed and later we will re-add it to the DetourNavMesh object. Read the comments to understand what does each function do. Much of the code you're going to see (maybe use) is copied from the engine. If you plan to upgrade in the future, you might want to keep an eye on this, in case you need to update the parts extracted from the engine.

[MyRecastNavMeshDataChunk.h](Source/MyRecastNavMeshDataChunk.h)

**.cpp**

```cpp
#include "MyRecastNavMeshDataChunk.h"

#include "Algo/Transform.h"
#include "Engine/LevelStreaming.h"
#include "NavMesh/NavMeshBoundsVolume.h"
#include "NavMesh/PImplRecastNavMesh.h"
#include "Navmesh/Public/Detour/DetourNavMesh.h"
#include "NavMesh/RecastNavMesh.h"
#include "NavMesh/RecastNavMeshDataChunk.h"
#include "Game/MyGameInstance.h"
#include "MyNavBoundsVolumeManagerSubsystem.h"
#include "DrawDebugHelpers.h"

TAutoConsoleVariable<bool> CVarMyProjectEnableNavChunkDebug(
	TEXT("MyProject.EnableNavChunkDebug"),
	false,
	TEXT("Enables visual debug for Nav Chunk operations"),
	ECVF_Cheat
);

TArray<uint32> UMyRecastNavMeshDataChunk::DetachTiles(FPImplRecastNavMesh& navMeshImpl,
	TArray<URecastNavMeshDataChunk*>& outChunksToRebuild)
{
	check(navMeshImpl.NavMeshOwner && navMeshImpl.NavMeshOwner->GetWorld());
	const bool bIsGameWorld = navMeshImpl.NavMeshOwner->GetWorld()->IsGameWorld();
	
	// Keep data in game worlds (in editor we have a copy of the data so we don't keep it).
	const bool bTakeDataOwnership = bIsGameWorld;
	const bool bTakeCacheDataOwnership = bIsGameWorld;
	
	return DetachTiles(navMeshImpl, bTakeDataOwnership, bTakeCacheDataOwnership, outChunksToRebuild);
}

TArray<uint32> UMyRecastNavMeshDataChunk::DetachTiles(FPImplRecastNavMesh& navMeshImpl, const bool bTakeDataOwnership,
	const bool bTakeCacheDataOwnership, TArray<URecastNavMeshDataChunk*>& outChunksToRebuild)
{
 	TArray<uint32> result;
	TArray<FRecastTileData> tiles = GetMutableTiles();
	result.Reserve(tiles.Num());

#if WITH_RECAST
	dtNavMesh* navMesh = navMeshImpl.DetourNavMesh;
	ARecastNavMesh* recastNav = navMeshImpl.NavMeshOwner;
	if (navMesh != nullptr)
	{
		TArray<ANavMeshBoundsVolume*> otherLevelsNavVolumesBounds;
		GetAvailableLevelsNavBoundsVolumes(recastNav, otherLevelsNavVolumesBounds);

		outChunksToRebuild.Reserve(tiles.Num());

		for (FRecastTileData& tileData  : tiles)
		{
			if (tileData.bAttached)
			{
				// Detach tile cache layer and take ownership over compressed data
				dtTileRef tileRef = 0;
				const dtMeshTile* meshTile = navMesh->getTileAt(tileData.X, tileData.Y, tileData.Layer);
				if (meshTile)
				{
					tileRef = navMesh->getTileRef(meshTile);

					if (bTakeCacheDataOwnership)
					{
						FNavMeshTileData tileCacheData = navMeshImpl.GetTileCacheLayer(tileData.X, tileData.Y, tileData.Layer);
						if (tileCacheData.IsValid())
						{
							tileData.TileCacheDataSize = tileCacheData.DataSize;
							tileData.TileCacheRawData->RawData = tileCacheData.Release();
						}
					}

					navMeshImpl.RemoveTileCacheLayer(tileData.X, tileData.Y, tileData.Layer);

					if (bTakeDataOwnership)
					{
						// Remove tile from navmesh and take ownership of tile raw data
						navMesh->removeTile(tileRef, &tileData.TileRawData->RawData, &tileData.TileDataSize);
					}
					else
					{
						// In the editor we have a copy of tile data so just release tile in navmesh
						navMesh->removeTile(tileRef, nullptr, nullptr);
					}

					// gather any nav chunk in the game that will need this tile re-attached
					ProcessOverlappingTileAndStoreAffectedNavChunk(recastNav, navMesh->getTileIndex(meshTile),
						otherLevelsNavVolumesBounds, outChunksToRebuild);

					result.Add(navMesh->decodePolyIdTile(tileRef));
				}
			}

			tileData.bAttached = false;
			tileData.X = 0;
			tileData.Y = 0;
			tileData.Layer = 0;
		}
	}
#endif// WITH_RECAST

	UE_LOG(LogNavigation, Log, TEXT("Detached %d tiles from NavMesh - %s"), result.Num(), *NavigationDataName.ToString());
	return result;
}

void UMyRecastNavMeshDataChunk::GetAavilableLevelsNavBoundsVolumes(ARecastNavMesh* navRecast,
	TArray<ANavMeshBoundsVolume*>& outNavBoundsVolumes)
{
	const UWorld* world = ::IsValid(navRecast) ? navRecast->GetWorld() : nullptr;
	if (::IsValid(world))
	{
		TRACE_CPUPROFILER_EVENT_SCOPE(TEXT("URecastNavMeshDataChunk::DetachTiles gatter nav bounds"));

		TArray<ULevelStreaming*> streamedLevels = world->GetStreamingLevels();

		UMyNavBoundsVolumeManagerSubsystem* navSubsystem = nullptr;

		if (streamedLevels.Num() > 0)
		{
			const UMyGameInstance* myGameInstance = ::IsValid(world) ? world->GetGameInstance<UMyGameInstance>() : nullptr;
			navSubsystem = ::IsValid(myGameInstance) ? myGameInstance->GetSubsystem<UMyNavBoundsVolumeManagerSubsystem>() : nullptr;
		}

		for (ULevelStreaming* streamedLevel : streamedLevels)
		{
			// Level not loaded? we don't care then. Only in-use sub levels matter
			ULevel* loadedLevel = streamedLevel->GetLoadedLevel();
			if (!::IsValid(loadedLevel))
			{
				continue;
			}

			// skip the about-to-be removed data chunk
			if (navRecast->GetNavigationDataChunk(loadedLevel) == this)
			{
				continue;
			}

			{
				TRACE_CPUPROFILER_EVENT_SCOPE(TEXT("URecastNavMeshDataChunk::DetachTiles Get nav bound actors"));
				
				if (::IsValid(navSubsystem))
				{
					navSubsystem->GetVolumesFromLevel(loadedLevel, outNavBoundsVolumes);
				}
				else
				{
					UE_LOG(LogNavigation, Warning, TEXT("%s Expensive path! no navSubSystem!"), *FString(__FUNCTION__));

					// grab all the nav mesh bounds from the other sub-levels
					auto conditionLambda = [](AActor* actorInLevel)
					{
						return ::IsValid(actorInLevel) && actorInLevel->IsA<ANavMeshBoundsVolume>();
					};
					auto transformLambda = [](AActor* actorInLevel)
					{
						return Cast<ANavMeshBoundsVolume>(actorInLevel);
					};

					Algo::TransformIf(loadedLevel->Actors, outNavBoundsVolumes, conditionLambda, transformLambda);
				}
			}
		}
	}
}

void UMyRecastNavMeshDataChunk::ProcessOverlappingTileAndStoreAffectedNavChunk(ARecastNavMesh* navRecast, const int32 tileIndex,
	TArray<ANavMeshBoundsVolume*> navBoundsToCheckAgainst, TArray<URecastNavMeshDataChunk*>& outAffectedNavChunks)
{
	if (::IsValid(navRecast))
	{
		const FBox& tileBounds = navRecast->GetNavMeshTileBounds(tileIndex);
		for (ANavMeshBoundsVolume* otherLevelNavBound : navBoundsToCheckAgainst)
		{
			if (::IsValid(otherLevelNavBound))
			{
				TRACE_CPUPROFILER_EVENT_SCOPE(TEXT("URecastNavMeshDataChunk::DetachTiles Intersect test"));
				const FBox& navBoundBox = otherLevelNavBound->GetBounds().GetBox();
#if ENABLE_DRAW_DEBUG
				const UWorld* world = CVarMyProjectEnableNavChunkDebug.GetValueOnGameThread() ? navRecast->GetWorld() : nullptr;
				if (::IsValid(world))
				{
					DrawDebugBox(world, navBoundBox.GetCenter(), navBoundBox.GetExtent(), FQuat::Identity, FColor::Red, false, 10.f);
					const FVector customExtent{ tileBounds.GetExtent().X, tileBounds.GetExtent().Y, 50.f };
					DrawDebugBox(world, tileBounds.GetCenter(), customExtent, FQuat::Identity, FColor::Orange, false, 10.f);
				}
#endif // ENABLE_DRAW_DEBUG
				// !tileBounds.IsValid: sometimes the bounds of a tile are not valid, which makes the Intersect test to fail
				// no matter what. This causes issues so, to prevent problems (tiles we need available but that actually being
				// detached forever), we force this failing tiles to be present again.
				if (!tileBounds.IsValid || FBoxSphereBounds::BoxesIntersect(navBoundBox, tileBounds))
				{
					URecastNavMeshDataChunk* navChunk = navRecast->GetNavigationDataChunk(otherLevelNavBound->GetLevel());
					outAffectedNavChunks.Emplace(navChunk);
				}
			}
		}
	}
}
```

- Now we need to use our newly created Nav Data Chunk child. For that, we need to create our own `ARecastNavMesh` and override couple functions, one that will be almost the same as the engine but that will create our own version of Nav Data Chunk. The other that will remove data chunks and then re-add the tiles that were deleted and shouldn't.

**.h**

```cpp
#pragma once
#include "Navmesh/RecastNavMesh.h"
#include "MyRecastNavMesh.generated.h"

/** Custom version of RecastNavMesh so we can have a say in how nav is handled*/
UCLASS()
class MY_API AMyRecastNavMesh : public ARecastNavMesh
{
	GENERATED_BODY()

public:
 	void DetachNavMeshDataChunk(URecastNavMeshDataChunk& navDataChunk) override;
 	void OnNavMeshGenerationFinished() override;
};
```

**.cpp**

```cpp
#include "MyRecastNavMesh.h"

#include "NavMesh/PImplRecastNavMesh.h"

#include "MyRecastNavMeshDataChunk.h"
#include "NavigationSystem.h"//UNavigationSystemV1

TAutoConsoleVariable<bool> CVarMyEnableCustomNavChunk(
	TEXT("my.EnableCustomNavChunk"),
	true,
	TEXT("Enables custom nav chunk that will enable all the optimizations for nav"),
	ECVF_Cheat
);

void AMyRecastNavMesh::DetachNavMeshDataChunk(URecastNavMeshDataChunk& navDataChunk)
{
	if (UMyRecastNavMeshDataChunk* myNavDataChunk = Cast<UMyRecastNavMeshDataChunk>(&navDataChunk))
	{
		FPImplRecastNavMesh* recastImpl = GetRecastNavMeshImpl();
		if (ensureMsgf(recastImpl != nullptr, TEXT("%s no valid RecastImpl!"), *FString(__FUNCTION__)))
		{
			TArray<URecastNavMeshDataChunk*> navDataChunksToRebuild;
			TArray<uint32> DetachedIndices = myNavDataChunk->DetachTiles(*recastImpl, navDataChunksToRebuild);
			if (DetachedIndices.Num() > 0)
			{
				// re-attach missing tiles back to the nav that the currently loaded nav chunks also need
				if (navDataChunksToRebuild.Num() > 0)
				{
					for (URecastNavMeshDataChunk* chunk : navDataChunksToRebuild)
					{
						if (::IsValid(chunk))
						{
							chunk->AttachTiles(*recastImpl);
						}
					}
				}

				InvalidateAffectedPaths(DetachedIndices);
				RequestDrawingUpdate();
			};
		}
	}
	else
	{
		Super::DetachNavMeshDataChunk(navDataChunk);
	}
}

void AMyRecastNavMesh::OnNavMeshGenerationFinished()
{
	// Copy/pasted from the engine original. Only change is that we create our own version of URecastNavMeshDataChunk (UMyRecastNavMeshDataChunk)
	UWorld* world = GetWorld();

	if (world != nullptr && world->IsPendingKill() == false)
	{
#if WITH_EDITOR	
		// For navmeshes that support streaming create navigation data holders in each streaming level
		// so parts of navmesh can be streamed in/out with those levels
		if (!world->IsGameWorld())
		{
			const auto& levels = world->GetLevels();
			for (auto level : levels)
			{
				if (level->IsPersistentLevel())
				{
					continue;
				}

				URecastNavMeshDataChunk* navDataChunk = GetNavigationDataChunk(level);

				if (SupportsStreaming())
				{
					// We use navigation volumes that belongs to this streaming level to find tiles we want to save
					TArray<int32> levelTiles;
					TArray<FBox> levelNavBounds = GetNavigableBoundsInLevel(level);

					FPImplRecastNavMesh* recastNavMeshImpl = GetRecastNavMeshImpl();
					recastNavMeshImpl->GetNavMeshTilesIn(levelNavBounds, levelTiles);

					if (levelTiles.Num())
					{
						// Create new chunk only if we have something to save in it			
						if (navDataChunk == nullptr)
						{
							if (CVarMyEnableCustomNavChunk.GetValueOnGameThread())
							{
								navDataChunk = NewObject<UMyRecastNavMeshDataChunk>(level);
							}
							else
							{
								navDataChunk = NewObject<URecastNavMeshDataChunk>(level);
							}
							navDataChunk->NavigationDataName = GetFName();
							level->NavDataChunks.Add(navDataChunk);
						}

						const EGatherTilesCopyMode CopyMode = recastNavMeshImpl->NavMeshOwner->SupportsRuntimeGeneration()
							? EGatherTilesCopyMode::CopyDataAndCacheData : EGatherTilesCopyMode::CopyData;
						navDataChunk->GetTiles(recastNavMeshImpl, levelTiles, CopyMode);
						navDataChunk->MarkPackageDirty();
						continue;
					}
				}

				// stale data that is left in the level
				if (navDataChunk)
				{
					// clear it
					navDataChunk->ReleaseTiles();
					navDataChunk->MarkPackageDirty();
					level->NavDataChunks.Remove(navDataChunk);
				}
			}
		}

		// force navmesh drawing update
		RequestDrawingUpdate(/*bForce=*/true);
#endif// WITH_EDITOR

		UNavigationSystemV1* navSys = FNavigationSystem::GetCurrent<UNavigationSystemV1>(world);
		if (navSys)
		{
			navSys->OnNavigationGenerationFinished(*this);
		}
	}
}
```

Up to this point you now have everything you need:

- A system to where add/get the nav volumes of specific levels in an automated/fast way
- A way to control that, when tiles are detached from the world due to levels being unloaded, you don't miss tiles that are supposed to be there

- At this point, if you tried to compile, you probably couldn't. That's because there are two final steps to do:
    - Change the modules configuration of your project. Open the file `[MyProjectName]\Source\[MyProjectName]\MyProjectName.Build.cs` and add, to `PublicDependencyModuleNames` , `"NavigationSystem"` and `"NavMesh"` .
        
        ```cpp
        public class My: ModuleRules
        {
			public My(ReadOnlyTargetRules Target) : base(Target)
			{
        		PublicDependencyModuleNames.AddRange(
        		new string[] {
        			// other modules you have for your project
        			"NavigationSystem",
        			"NavMesh",
        		}
        		);
			}
        }
        ```
        
    - Unfortunately, you need to modify the engine source. But it's a small change. Go to `Engine\Source\Runtime\NavigationSystem\Public\NavMesh\RecastNavMesh.h` and look for the definition of `FNavMeshTileData` (at the moment of writing and using UE4.27, it was line 338). Add the API macro to add this struct as one of the parts exported with the Navigation module. We need this for the custom `MyRecastNavMeshDataChunk` to be able to access the tile data.
        
        ```cpp
        /**
         *	Structure to handle nav mesh tile's raw data persistence and releasing
         */
        struct NAVIGATIONSYSTEM_API FNavMeshTileData // added API export
        	// We Need this in the game project to compile MyRecastNavMeshDataChunk.cpp 
        {
        ```